
# Factorial giving the compiler the chance to tail call optimise
# Aggressive type inference means that the return type of 'factorial' is determined

fun `*`(a, b) = __builtin__ mul_i32(a, b)
fun `-`(a, b) = __builtin__ sub_i32(a, b)
fun `=`(a, b) = __builtin__ equ_i32(a, b)

fun factorial(n, a) = n = 1 ? a : factorial(n-1, n*a)

fun main() = factorial(5, 1)

