
# First heap object via global variable, second referenced by a third, and a tuple referencing a heap object.
# Reference counts are kept cleanly and on exit there is exactly zero heap usage.
# Demonstrates that memory management thoroughly cleans up as it goes.
# Also shows more complex type inference.

fun `+`(a, b) = __builtin__ add_i32(a, b)
fun `+`(a, b) = __builtin__ add_i64(a, b)

class Number(value)
class Nested(number)

# Global reference to heap object must be cleaned up on exit
val x = Number(27)

# Tuple references heap object that in turn references another heap object
fun make() = (one = 1, two = Nested(Number(2)))

# Conditional mixes owned object with borrowed object
fun other(cond) = cond ? Number(28) : x

# Lots of temporaries
fun main() = make().two.number.value + other(false).value
