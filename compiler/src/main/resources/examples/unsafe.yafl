# Unsafe code can do more, but has less implicit help
# For example, unsafe code won't generate parallel code
# Keywords available to unsafe code are
#    var, null, nullable
# Library functions and classes marked as unsafe are also now available, such as
#    Mutex

# Mark this module as unsafe
unsafe module Corestuff

# Nullability is a language feature that is not normally available.
# The null and nullable keywords are not available in safe code.
#    sub-note, the semicolon is optional and added for readability
fun convert(a: TypeA): TypeB
    return if a != null; a.toString() else defaultOf<TypeB>()

# This function is so unsafe that I only want other unsafe modules to see it
unsafe fun doSomethingDangerous() = danger



# Mutability is a thing. The assignment operator ':=' is available only to unsafe code.
# The var keyword isn't available in safe code.
#   sub-note, This looks thread unsafe AND wastefully re-assigning on every call.
#             Since the generator is pure functional, the slight chance of calling it twice is ok.
#             We rely on the compiler a lot to optimise away redundant code. When it expands out the call
#             to orElse it'll notice that one code path results in no change.
class Lazy<Type>(private val generator: () -> Type)
    private var value: Optional<Type>
    fun get
        value := value.orElse(generator)
        return value


# Loops exist mainly to support lowering of tail recursion for inlining.
# Their use is discouraged, and exists mainly for debugging compilers.
# For that reason the keywords 'loop' and 'continue' are restricted to
# unsafe modules.
fun recursiveAddAll(seq: Optional<Sequence<Int>>, acc: Int = 0): Int
    seq.orElse(addAll($0.tail, acc + $0.head), acc)

# After inlining the Optional and then lowering the tail recursion, it might look like this
fun loopAddAll(seqParam: Optional<Sequence<Int>>, accParam: Int = 0): Int
    loop (seq = seqParam, acc = accParam)
        if seq.hasValue
            continue (seq = seq.value.tail, acc = acc + seq.head)
        else
            acc

# If the target type is an interface, we can help later optimisations by
# ensuring that the loop always works with a single variant of that interface.
fun loopAddAll(seqParam: Optional<Sequence<Int>>, accParam: Int = 0): Int
    if seqParam.hasValue
        # 'acc' is now always the result of the same '+' function and so
        # is highly likely to be of the exact same type. The compiler might
        # be able to move the now well defined heap object onto the stack.
        loop (seq = seqParam.value.tail, acc = accParam + seqParam.head)
            if seq.hasValue
                continue (seq = seq.value.tail, acc = acc + seq.head)
            else
                acc
    else
        accParam


