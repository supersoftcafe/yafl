
# Enum in YAFL is a cross between C enum and union.

# This is a simple enum
enum Colours
    def red
    def green
    def blue

# Same enum, even simpler
enum Colours(red, green, blue)

# This one carries data as well
enum Shapes
    def None
    def Circle(centre: Point, radius: Float)
    def Square(corner1: Point, corner2: Point)

# This is how to do something useful with an enum
fun myFunFun(value: Shapes): Float
    when value
        is None => -1F
        is Circle(centre, radius) => radius
        else => 2

# So is this, but we can't destructure them here
fun myFunFun(value: Shapes): Float
    if value = Circle
        1f
    else
        0f

# Shorthand for an anonymous enum to contain different types.
# A named var 'value' is implicitly extracted, if none are named. It is
# a tuple of all values, but remember that a single value is interchangeable
# with a tuple if itself. So in this case, it is the value.
fun myFunFun(value: Integer|Long|Float|Double): Double
    when value
        is Integer => value.asDouble()
        is Long => value.asDouble()
        is Float => value.asDouble()
        is Double => value

# Can use 'type' to give a name to this shorthand container
type Numbers: Integer|Long|Float|Double

# Lowers to
enum Number<Type>(Integer:Integer,Long:Long,Float:Float,Double:Double)

# And that lowers to
enum Number<Type>
    def Integer(value:Integer)
    def Long(value:Long)
    def Float(value:Float)
    def Double(value:Double)


# Finally we get Optional. Any enum that has this pattern, only two
# variants and just one of them has a single value, will be optimised
# by compiler for nullable types to use null itself to distinguish
# the variants.
enum Optional<Type>
    def Some(Type)
    def None
    fun orElse(alt: () -> Type) = when this; Some(value) = value; None => alt
    fun map<Result>(func: (Type) -> Result) = match this; Some(value) => Some(func(value)); None => None<Result>
    fun flatMap<Result>(func: (Type) -> Optional<Result>) = match this; Some(value) => func(value); None => None<Result>







