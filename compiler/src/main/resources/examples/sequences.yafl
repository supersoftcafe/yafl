


# An interface defines a set of type requirements. It is not quite like
# the same named concept in Java or C#, where it has concrete meaning.
# Here anything can be said to be of this interface if it meets the
# minimum requirements specified, i.e. it has the specified functions
# available.
interface Sequence<Type>
    fun head(): Type
    fun tail(): Optional<Sequence<Type>>

fun toSequence<Type>(array: Array<Type>, start: Int)
    return if (start >= array.length) default
    else Sequence(array[start], array.toSequence(start+1))

# Filter a sequence, using lazy evaluation.
# Note the constructor syntax of Sequence. It means, give me an object that meets
# the interface requirements, and in order define the functions using these expressions.
fun filter<Type>(seq: Optional<Sequence<Type>>, pred: (Type)->Bool) = seq.apply( value =>
    if ( pred( value ) ) Optional( Sequence( value.head, filter( value.tail, pred ) ) )
    else filter( value.tail, pred ) )

fun map<Type, Result>(seq: Optional<Sequence<Type>>, functor: (Type)->Result) = seq.apply( value =>
    Sequence( functor( value.head ), value.tail.map(functor) ) )

fun pairwise<Type>(seq: Optional<Sequence<Type>>) = seq.apply( left => left.tail.apply( right =>
    Sequence( (left.head, right.head), left.tail.pairwise() ) ) )

# These next methods are to support implicit conversion to sequences. There are no implicit
# conversions in YAFL, but we can make life easier through function overloads.
fun filter<Type,Container>(cont: Container, pred: (Type)->Bool) = cont.toSequence().filter(pred)
fun map<Type,Result,Container>(cont: Container, functor: (Type)->Result) => cont.toSequence().map(functor)
fun pairwise<Type,Container>(cont: Container) => cont.toSequence().pairwise()


# Methods such as .sum and .toArray can be derived from this one method.
# The tail recursion is not obvious, as it's done through a lambda, but due to
# inlining and static code analysis it will end up being tail call optimised.
fun accumulate<Type, Result>(seq: Optional<Sequence<Type>>, accumulator: (Result,Type) -> Result, result: Result = default)
    return seq.orElse(value => value.tail.accumulate(accumulator, accumulator(result, value.head)), result)

# We require an identity function and a binary associative operator to do sum.
# Specifying that as a trait is nice, but not required. The compiler will emit
# some sort of error of the function cannot apply to the type given anyway. It
# won't be as nice.
fun sum<Type : Monoid>(seq: Optional<Sequence<Type>>) = seq.accumulate(Type.`+`)

# Average demonstrates passing a tuple on the left of a function, basically
# pipelining with more than one parameter value. The ultimate result of
# accumulate is a sum and a count, now we need to divide sum by count, so
# apply the divide function.
fun average<Type>(seq: Optional<Sequence<Type>>) = seq.accumulate((acc, value) => (acc[0] + value, acc[1] + 1)).`/`

# This looks inefficient, but again we rely heavily on the compiler to optimise
# this kind of recursive logic. An array often has spare space at the end of
# the heap and so if it is provable that this code holds the only reference to
# the array, a safe in-place modification is done.
fun toArray<Type>(seq: Optional<Sequence<Type>>) = seq.accumulate((arr, value) => arr.append(value), Array<Type>.default)



fun toArray<Type>(s1: Optional<Sequence<Type>>): Array<Type>
    return if s1 is Optional.None
        Array<Type>()
    else if val (v1, s2) = (s1.head, s1.tail), s2 is Optional.None
        Array<Type>(v1)
    else if val (v2, s3) = (s2.head, s2.tail), s3 is Optional.None
        Array<Type>(v1, v2)
    else if val (v3, s4) = (s3.head, s3.tail), s4 is Optional.None
        Array<Type>(v1, v2, v3)
    else
        Array<Type>(v1, v2, v3, s4.head).concat(s4.tail.toArray())




# An example of using the sequence library to transform an array.
# There is a simple example of currying with the filter functions lambda parameter.
# If the curried function is overloaded, it must be unambiguous in this context.
# It is highly likely that the compiler will optimise this entire expression away
# using its internal evaluator, if it can execute without exceeding compile time
# resource constraints. This is the central pillar of compile time code (and data)
# generation.
val dataAsStrings = ["1", "2", "3", "4", "5", "6"]
val dataAsNumbers = dataAsStrings .map(Int.parse) .filter(_<5) .toArray()




