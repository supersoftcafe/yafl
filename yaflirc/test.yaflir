#### Types
# v   = void
# b   = bool
# p   = pointer to data
# m   = pointer to method
# c   = atomic counter
# i1  = i8
# i2  = i16
# i4  = i32
# i8  = i64
# is  = size_t or equiv
# f4  = float
# f8  = double
# u?v = union, sequence of types, terminates on 'v'
# s?v = struct, terminates on 'v'
# aN?  = array, followed by size and type. 0 is valid size for top level struct's last field

target datalayout = "e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-macosx12.0.0"

data const @whaaaa:ui2si2f4vv
  u 0 # Union member selector must occur before actual union member data
  i2 27
end

# @ literals are pointers to compile time stuff
# Each line is a literal value that contributes to the struct value.
# There must be an exact match to the type layout
data const @someInterfaceVTable:spa2ma2ui2si2f4vvv
  p @someInterfaceVTable
  m @main
  m @freeCharArray
  u 0 # Union member selector must occur before actual union member data
  i2 27
  u 1 # Union member selector must occur before actual union member data
  i2 15
  f4 3.000000e+00
end




data @somethingGlobalButSimple:i4
  i4  101
end


method @useOfMalloc:p %p0:i4
  %r0:p
begin
  malloc %r0 si4i4i4a0si8i8vv %p0
  ret %r0
end

method @useOfFree:v %p0:p
begin
  free %p0
  ret void
end

method @useOfAcquireAndRelease:p %p0:p.spci4i4i4v
  %reached_zero:b
begin
  acquire %p0/1
  release %p0/1 %reached_zero
  br %reached_zero :if_true :if_false
:if_true
  ret null
:if_false
  ret %p0
end


method @setSomethingGlobalButSimple:v %p0:i4
begin
  mov @somethingGlobalButSimple %p0
  ret void
end

method @getSomethingGlobalButSimple:i4
begin
  ret @somethingGlobalButSimple
end

method @testGlobalArraySubscript:f4 %p0:i4
begin
  ret @someInterfaceVTable/2/%p0/1/1
end

# method @testGlobalStruct:p
# begin
#   ret @someInterfaceVTable/0
# end

method @testAfterUnion:i1 %p0:p.si1ui4i8i2vi1v
begin
  ret %p0/2
end

method @testUnion:i2 %p0:p.ui4i8i2v
begin
  ret %p0/2
end

method @testSimpleStruct:i4 %p0:p
  %r0:p.si4i4v
begin
  mov %r0 %p0
  ret %r0/1
end

method @freeCharArray:i4 %p0:i4
  %r0:i4
  %overflow:b
begin
  add %r0 %p0 20 %overflow
  br %overflow :if_true :if_false
:if_true
  ret %r0
:if_false
  ret -1
end


method @main:i4 %p0:i4 %p1:p.a0i8
  %r0:i4
  %r1:i4
  %overflow:b
begin
  call i4.si4v %r0 @freeCharArray %p0
  add %r1 %r0 10 %overflow
  br %overflow :if_true :if_false
:if_true
  ret %r1
:if_false
  ret -1
end


method @testSwitch:p %p0:i4 %p1:p %p2:p %p3:p %p4:p
begin
  switch %p0 :default 0:on0 1:on1 2:on2 3:on3
:default
  ret null
:on0
  ret %p1
:on1
  ret %p2
:on2
  ret %p3
:on3
  ret %p4
end