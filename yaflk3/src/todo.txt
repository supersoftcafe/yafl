
# Arrays, get rid of max size specifier.
# Get rid of Declaration.Enum, replace it with a direct tagged value type instead like tuple.
# e.g. fun egg() => |some(1)    # return tag |some with value 1
#      fun bacon(cond) => cond ? |some(1) : |none  # left returns tagged some, right returns tagged none
#                                                  # function returns |some(Int)|none
# multiple tagged input types can be combined so |some(Int)|none can be passed to a function
# that takes |some(Int)|error(String)|none just as well. But it can't take |some(String)|none.
#
# hopefully this avoids the need for generics for a while



# more thoughts on lazy...  there are smart ways to do it, but should we?






# Todo

** Pre-calculate so called "transport types" of CgType into a Map<Named,CgType>.



Generics
- Type inference should only take hints against types that are visible at the target site.
  However, alias types screw this up a bit, because the target of an alias may not be visible at the usage site.
  Needs more thought.

  Rename TypeRef.Named to TypeRef.Klass.
  Add TypeRef.Generic.
  A type hint for a target declaration can only be used if all TypeRef.Generic within (because it might be
  a nested type ref) are visible at the target site.




Add struct support.

Index access to tuple using variable if all elements are of same type.
Index access to any tuple using constant literal.

Add enum support. Do basic implementation with selector first.

Optimise enums for compressed formats that use lower bits of pointer members.

Nested enums to share selector word where possible.
   I can see situation of Either being enum, but within is String which is also an enum.
   That should still efficiently fit in registers and return from a function efficiently.

Convert String to group of types centred on an enum definition. Goal is that short strings
and especially single codepoint strings do not require a heap allocation. Yafl will not
have a Char type, so short strings must be efficient.







Improve output during compilation to print phase info as it goes.

Integer constants can self promote their type to wider integers.

Update globals to have pointer to string and pointer to vtable with proper global type instead of specific type
to reduce IR codegen and amount of temporary registers.



Add generics support.

Add explicit currying of calls using $1 etc parameters, replacing with lambda in AST.
Put small and simple classes on the stack.


# Notes

## 'if' as well as '?' support
For clearer code. Maybe add 'when' as well, at least a simple version for now.

## General statement sequences
This is a bit like doing 'let x = print(60)' and then discarding x. Semantically the same, so why not support statements?

## Anonymous objects
Anonymous object creation can only define functions, as its only purpose is to implement an interface. All state is from capture of locals.

## Class changes
Replace 'class' and 'struct' with 'type'. Compiler decides how to implement each one.
* Can only extend interfaces.
* Can only be stack allocated if <= 32 bytes, <= 1 object ref, <= 0 interfaces

## Calling conventions to improve ref counting performance
<return type> Func(void** deferredReleaseArea, void* this, params...)
A function keeps its own internal deferred release area but also can add to the caller supplied deferred release area.
A function that returns an object from its parameter list will not need to update the deferredReleaseArea.
The deferredReleaseArea is big enough to hold all pointers in the return type and is initialised to null.

## Currying
Get rid of tuple unpack. Apply operator takes callable expression result as right arg and a call is curried explicitly instead:
  e.g someValue |> doSomething(87, $1)
  is equivalent to to doSomething(87, $1)(someValue)
Conditional apply (think Monad) operator is done like Haskell using map that takes callable param. This requires generics.

## Arrays
Any class parameter can be an array. It is initialised with a callable param.
  class Cat(legs: Leg[4])   # Fixed length array
  class Something(a: Quark[4], size: Int32, b: Blob[size])  # Variable size array must be last parameter

## Generics

## Enums

## Pattern matching switch expression

## Deconstructing declarations for parameters and for let statements

## Apply operator

## Lazy evaluation
Parameter, to function or class, can be marked with & to mean that the expression passed in at any call
site is implicitly converted to a lambda, and the parameter itself is a callable that returns the given
value.

## Mutability
Add mutable support with 'mutable' attribute and enforcement. 'mutable' attribute cannot be inferred, it must be explicit.
Add mutation operator ':='.
Add 'new' operator that implicitly returns a mutable type.