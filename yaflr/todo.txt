
Remember this is all predicated on the language being pure functional with no lazy thunks. All heap
allocation is local.

TODO:

* Re-visit Yafl compiler to generate C instead of LLVM-IR. Can work with any C11 compliant compiler.

* Large objects. Any object that closes in on 64K still gets allocated in the normal way, but pages
  with small amounts of space left are kept around as candidates for small allocations, to try to
  avoid wasting space. Only when the allocation exceeds the maximum that the 64K+overheads page can
  hold do we move to an explicit 'mmap' based allocation. These large areas are not retained in a
  free list like the 64K pages, and so have additional overhead.

* Macros to help with defining classes in C for testing and library implementations.

* Object with fiber behaviour...  How to clean up?   How to trigger behaviour and transfer result?

* IO

